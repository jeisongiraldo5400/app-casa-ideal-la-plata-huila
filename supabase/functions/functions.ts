[
    {
        "routine_name": "update_entry_cancellation_updated_at",
        "routine_definition": "\nBEGIN\n    NEW.updated_at = NOW();\n    RETURN NEW;\nEND;\n"
    },
    {
        "routine_name": "update_exit_cancellation_updated_at",
        "routine_definition": "\nBEGIN\n    NEW.updated_at = NOW();\n    RETURN NEW;\nEND;\n"
    },
    {
        "routine_name": "get_reports_stats_today",
        "routine_definition": "\nWITH today_range AS (\n    SELECT\n        date_trunc('day', CURRENT_TIMESTAMP AT TIME ZONE 'America/Bogota') AS start_time,\n        date_trunc('day', CURRENT_TIMESTAMP AT TIME ZONE 'America/Bogota') + INTERVAL '1 day' AS end_time\n),\nentries_stats AS (\n    SELECT\n        COUNT(*) AS entries_count,\n        COALESCE(SUM(quantity), 0) AS entries_qty\n    FROM public.inventory_entries ie\n    CROSS JOIN today_range tr\n    WHERE ie.created_at >= tr.start_time\n      AND ie.created_at < tr.end_time\n),\nexits_stats AS (\n    SELECT\n        COUNT(*) AS exits_count,\n        COALESCE(SUM(quantity), 0) AS exits_qty\n    FROM public.inventory_exits ie\n    CROSS JOIN today_range tr\n    WHERE ie.created_at >= tr.start_time\n      AND ie.created_at < tr.end_time\n),\ncancelled_entries AS (\n    SELECT COUNT(*) AS count\n    FROM public.inventory_entry_cancellations iec\n    CROSS JOIN today_range tr\n    WHERE iec.created_at >= tr.start_time\n      AND iec.created_at < tr.end_time\n),\ncancelled_exits AS (\n    SELECT COUNT(*) AS count\n    FROM public.inventory_exit_cancellations iec\n    CROSS JOIN today_range tr\n    WHERE iec.created_at >= tr.start_time\n      AND iec.created_at < tr.end_time\n),\nstock_total AS (\n    SELECT COALESCE(SUM(quantity), 0) AS total\n    FROM public.warehouse_stock\n)\nSELECT\n    (es.entries_count + exs.exits_count) AS movements_today,\n    es.entries_count AS entries_today,\n    exs.exits_count AS exits_today,\n    es.entries_qty AS entries_quantity_today,\n    exs.exits_qty AS exits_quantity_today,\n    st.total AS total_stock,\n    ce.count AS cancelled_entries_today,\n    cex.count AS cancelled_exits_today\nFROM entries_stats es\nCROSS JOIN exits_stats exs\nCROSS JOIN cancelled_entries ce\nCROSS JOIN cancelled_exits cex\nCROSS JOIN stock_total st;\n"
    },
    {
        "routine_name": "search_customers",
        "routine_definition": "\nDECLARE\n    _search text := COALESCE(LOWER(TRIM(search_term)), '');\n    _limit integer := GREATEST(COALESCE(limit_count, 20), 1);\nBEGIN\n    RETURN QUERY\n    SELECT\n        c.id,\n        c.name::text,\n        c.id_number::text,\n        c.address::text\n    FROM public.customers c\n    WHERE c.deleted_at IS NULL\n      AND (\n        _search = ''\n        OR LOWER(c.name) LIKE '%' || _search || '%'\n        OR LOWER(c.id_number) LIKE '%' || _search || '%'\n      )\n    ORDER BY c.name ASC\n    LIMIT _limit;\nEND;\n"
    },
    {
        "routine_name": "generate_delivery_order_number",
        "routine_definition": "\nDECLARE\n    order_year INTEGER;\n    next_sequence INTEGER;\n    new_order_number TEXT;\nBEGIN\n    -- Obtener el año de la orden\n    order_year := EXTRACT(YEAR FROM NEW.created_at);\n    \n    -- Obtener el siguiente número secuencial del año\n    -- Busca el máximo número que coincida con el patrón OE-YYYY-NNNN\n    SELECT COALESCE(MAX(\n        CAST(SUBSTRING(order_number FROM 'OE-\\d+-(\\d+)') AS INTEGER)\n    ), 0) + 1\n    INTO next_sequence\n    FROM public.delivery_orders\n    WHERE order_number LIKE 'OE-' || order_year || '-%'\n      AND deleted_at IS NULL;\n    \n    -- Generar el número de orden en formato OE-YYYY-NNNN\n    new_order_number := 'OE-' || order_year || '-' || LPAD(next_sequence::TEXT, 4, '0');\n    \n    -- Asignar el número de orden\n    NEW.order_number := new_order_number;\n    \n    RETURN NEW;\nEND;\n"
    },
    {
        "routine_name": "get_customers_dashboard",
        "routine_definition": "\nDECLARE\n    _limit integer := GREATEST(COALESCE(page_size, 5), 1);\n    _offset integer := GREATEST((COALESCE(page, 1) - 1) * _limit, 0);\n    _search text := COALESCE(LOWER(TRIM(search_term)), '');\nBEGIN\n    RETURN QUERY\n    WITH filtered AS (\n        SELECT\n            c.id,\n            c.name,\n            c.id_number,\n            c.email,\n            c.phone,\n            c.address,\n            c.notes,\n            c.created_at,\n            c.created_by\n        FROM public.customers c\n        WHERE c.deleted_at IS NULL\n          AND (\n            _search = ''\n            OR LOWER(c.name) LIKE '%' || _search || '%'\n            OR LOWER(c.id_number) LIKE '%' || _search || '%'\n            OR LOWER(COALESCE(c.email, '')) LIKE '%' || _search || '%'\n            OR LOWER(COALESCE(c.phone, '')) LIKE '%' || _search || '%'\n          )\n    ),\n    enriched AS (\n        SELECT\n            f.*,\n            pr.full_name AS created_by_name,\n            COALESCE(exit_stats.total_exits, 0)::bigint AS total_exits,\n            exit_stats.last_exit_date\n        FROM filtered f\n        LEFT JOIN public.profiles pr ON pr.id = f.created_by\n        LEFT JOIN LATERAL (\n            SELECT\n                COUNT(*)::bigint AS total_exits,\n                MAX(ie.created_at) AS last_exit_date\n            FROM public.inventory_exits ie\n            WHERE ie.delivered_to_customer_id = f.id\n        ) exit_stats ON true\n    ),\n    numbered AS (\n        SELECT\n            e.*,\n            COUNT(*) OVER () AS total_count,\n            ROW_NUMBER() OVER (ORDER BY e.created_at DESC) AS row_number\n        FROM enriched e\n    )\n    SELECT\n        n.id,\n        n.name::text,\n        n.id_number::text,\n        n.email::text,\n        n.phone::text,\n        n.address::text,\n        n.notes::text,\n        n.created_at,\n        n.created_by,\n        n.created_by_name::text,\n        n.total_exits,\n        n.last_exit_date,\n        n.total_count\n    FROM numbered n\n    WHERE n.row_number > _offset\n    ORDER BY n.row_number\n    LIMIT _limit;\nEND;\n"
    },
    {
        "routine_name": "get_inventory_entries_stats",
        "routine_definition": "\nWITH entries AS (\n    SELECT\n        ie.id,\n        ie.quantity,\n        ie.warehouse_id,\n        iec.id AS cancellation_id\n    FROM public.inventory_entries ie\n    LEFT JOIN public.inventory_entry_cancellations iec ON iec.inventory_entry_id = ie.id\n)\nSELECT\n    COUNT(*) AS total_entries,\n    COALESCE(SUM(quantity), 0) AS total_quantity,\n    COUNT(DISTINCT warehouse_id) AS unique_warehouses,\n    COUNT(*) FILTER (WHERE cancellation_id IS NULL) AS active_entries,\n    COUNT(*) FILTER (WHERE cancellation_id IS NOT NULL) AS cancelled_entries\nFROM entries;\n"
    },
    {
        "routine_name": "get_customers_stats",
        "routine_definition": "\nWITH customer_exits AS (\n    SELECT\n        c.id AS customer_id,\n        COUNT(ie.id) AS exit_count\n    FROM public.customers c\n    LEFT JOIN public.inventory_exits ie ON ie.delivered_to_customer_id = c.id\n    WHERE c.deleted_at IS NULL\n    GROUP BY c.id\n)\nSELECT\n    COUNT(DISTINCT ce.customer_id) AS total_customers,\n    COUNT(DISTINCT ce.customer_id) FILTER (WHERE ce.exit_count > 0) AS customers_with_exits,\n    COUNT(DISTINCT ce.customer_id) FILTER (WHERE ce.exit_count = 0) AS customers_without_exits,\n    COALESCE(SUM(ce.exit_count), 0)::bigint AS total_exits_to_customers\nFROM customer_exits ce;\n"
    },
    {
        "routine_name": "update_delivery_order_progress",
        "routine_definition": "\nDECLARE\n  current_delivered INTEGER;\n  total_quantity INTEGER;\n  all_items_delivered BOOLEAN;\n  item_exists BOOLEAN;\n  current_status TEXT;\nBEGIN\n  -- Verificar que el item existe en la orden\n  -- Nota: delivery_order_items no tiene columna deleted_at\n  SELECT EXISTS (\n    SELECT 1 FROM delivery_order_items\n    WHERE delivery_order_id = order_id_param\n      AND product_id = product_id_param\n  ) INTO item_exists;\n  \n  IF NOT item_exists THEN\n    RETURN jsonb_build_object(\n      'success', false,\n      'error', 'Product not found in delivery order'\n    );\n  END IF;\n  \n  -- Actualizar delivered_quantity\n  -- Nota: delivery_order_items no tiene columnas updated_at ni deleted_at\n  UPDATE delivery_order_items\n  SET \n    delivered_quantity = delivered_quantity + quantity_delivered_param\n  WHERE delivery_order_id = order_id_param\n    AND product_id = product_id_param\n  RETURNING delivered_quantity, quantity INTO current_delivered, total_quantity;\n  \n  -- Verificar si excede la cantidad total\n  IF current_delivered > total_quantity THEN\n    -- Revertir el cambio\n    UPDATE delivery_order_items\n    SET \n      delivered_quantity = delivered_quantity - quantity_delivered_param\n    WHERE delivery_order_id = order_id_param\n      AND product_id = product_id_param;\n      \n    RETURN jsonb_build_object(\n      'success', false,\n      'error', 'Delivered quantity exceeds total quantity',\n      'current_delivered', current_delivered - quantity_delivered_param,\n      'total_quantity', total_quantity\n    );\n  END IF;\n  \n  -- Verificar si todos los items están entregados\n  SELECT NOT EXISTS (\n    SELECT 1 FROM delivery_order_items\n    WHERE delivery_order_id = order_id_param\n      AND delivered_quantity < quantity\n  ) INTO all_items_delivered;\n  \n  -- Si todos están entregados, actualizar estado de la orden a 'received'\n  -- Solo si el estado actual es 'pending' o 'approved' (no si ya es 'received' o 'cancelled')\n  IF all_items_delivered THEN\n    -- Obtener el estado actual de la orden\n    SELECT status INTO current_status\n    FROM delivery_orders\n    WHERE id = order_id_param;\n    \n    -- Solo actualizar si el estado permite la transición\n    IF current_status IN ('pending', 'approved') THEN\n      UPDATE delivery_orders\n      SET \n        status = 'received',\n        updated_at = NOW()\n      WHERE id = order_id_param\n        AND status IN ('pending', 'approved');\n    END IF;\n  END IF;\n  \n  RETURN jsonb_build_object(\n    'success', true,\n    'all_delivered', all_items_delivered,\n    'current_delivered', current_delivered,\n    'total_quantity', total_quantity,\n    'pending_quantity', total_quantity - current_delivered\n  );\nEND;\n"
    },
    {
        "routine_name": "get_warehouses_stats",
        "routine_definition": "\n  SELECT \n    w.id,\n    w.name,\n    w.city,\n    w.address,\n    w.is_active,\n    COUNT(DISTINCT CASE WHEN ws.quantity > 0 THEN ws.product_id END) as total_products,\n    COALESCE(SUM(CASE WHEN ws.quantity > 0 THEN ws.quantity ELSE 0 END), 0) as total_units,\n    MAX(ws.updated_at) as last_activity\n  FROM warehouses w\n  LEFT JOIN warehouse_stock ws ON w.id = ws.warehouse_id\n  GROUP BY w.id, w.name, w.city, w.address, w.is_active\n  ORDER BY w.name ASC;\n"
    },
    {
        "routine_name": "fn_update_stock_on_entry",
        "routine_definition": "\nBEGIN\n  -- Insertamos o Actualizamos (Upsert) en warehouse_stock\n  INSERT INTO public.warehouse_stock (product_id, warehouse_id, quantity, updated_at)\n  VALUES (NEW.product_id, NEW.warehouse_id, NEW.quantity, NOW())\n  ON CONFLICT (product_id, warehouse_id)\n  DO UPDATE SET \n      quantity = warehouse_stock.quantity + NEW.quantity,\n      updated_at = NOW();\n\n  RETURN NEW;\nEND;\n"
    },
    {
        "routine_name": "fn_update_stock_on_exit",
        "routine_definition": "\nDECLARE\n  current_stock numeric;\nBEGIN\n  -- 1. Obtener stock actual Y BLOQUEAR LA FILA (FOR UPDATE)\n  -- Esto hace que otras transacciones esperen si intentan tocar este producto/bodega\n  SELECT quantity INTO current_stock\n  FROM public.warehouse_stock\n  WHERE product_id = NEW.product_id\n    AND warehouse_id = NEW.warehouse_id\n  FOR UPDATE; -- <--- ESTO ES CLAVE\n\n  -- 2. Validar existencia del registro\n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'No existe registro de stock para el producto (%) en la bodega (%).',\n      NEW.product_id, NEW.warehouse_id;\n  END IF;\n\n  -- 3. Validar disponibilidad\n  IF current_stock < NEW.quantity THEN\n    RAISE EXCEPTION 'Stock insuficiente. Disponible: %, Solicitado: %',\n      current_stock, NEW.quantity;\n  END IF;\n\n  -- 4. Actualizar stock\n  UPDATE public.warehouse_stock\n  SET quantity = quantity - NEW.quantity,\n      updated_at = NOW()\n  WHERE product_id = NEW.product_id\n    AND warehouse_id = NEW.warehouse_id;\n\n  RETURN NEW;\nEND;\n"
    },
    {
        "routine_name": "validate_inventory_entry_quantity",
        "routine_definition": "\n\nDECLARE\n\n  order_item_quantity INTEGER;\n\n  total_registered INTEGER;\n\n  order_status TEXT;\n\n  order_exists BOOLEAN;\n\nBEGIN\n\n  -- Solo validar si hay una orden de compra asociada\n\n  IF NEW.purchase_order_id IS NULL THEN\n\n    RETURN NEW;\n\n  END IF;\n\n\n\n  -- Verificar que la orden existe y obtener su estado\n\n  SELECT \n\n    po.status,\n\n    EXISTS(SELECT 1 FROM purchase_orders WHERE id = NEW.purchase_order_id AND deleted_at IS NULL)\n\n  INTO order_status, order_exists\n\n  FROM purchase_orders po\n\n  WHERE po.id = NEW.purchase_order_id\n\n    AND po.deleted_at IS NULL;\n\n\n\n  IF NOT order_exists THEN\n\n    RAISE EXCEPTION 'La orden de compra % no existe o ha sido eliminada', NEW.purchase_order_id;\n\n  END IF;\n\n\n\n  -- Verificar que la orden esté en estado válido (pending)\n\n  -- Solo para entradas con tipo PO_ENTRY, pero validamos cantidades siempre\n\n  IF NEW.entry_type = 'PO_ENTRY' AND order_status != 'pending' THEN\n\n    RAISE EXCEPTION 'La orden de compra % no está en estado pendiente (estado actual: %). No se pueden registrar más entradas.', \n\n      NEW.purchase_order_id, order_status;\n\n  END IF;\n\n\n\n  -- Obtener la cantidad ordenada para este producto en la orden\n\n  SELECT quantity\n\n  INTO order_item_quantity\n\n  FROM purchase_order_items\n\n  WHERE purchase_order_id = NEW.purchase_order_id\n\n    AND product_id = NEW.product_id;\n\n\n\n  -- Si no hay item en la orden para este producto, rechazar\n\n  IF order_item_quantity IS NULL THEN\n\n    RAISE EXCEPTION 'El producto % no está incluido en la orden de compra %', \n\n      NEW.product_id, NEW.purchase_order_id;\n\n  END IF;\n\n\n\n  -- Calcular la cantidad total ya registrada para este producto en esta orden\n\n  -- Sumar todas las entradas existentes (excluyendo la actual si es un UPDATE)\n\n  SELECT COALESCE(SUM(quantity), 0)\n\n  INTO total_registered\n\n  FROM inventory_entries\n\n  WHERE purchase_order_id = NEW.purchase_order_id\n\n    AND product_id = NEW.product_id\n\n    AND (TG_OP = 'INSERT' OR id != NEW.id); -- Excluir la fila actual si es UPDATE\n\n\n\n  -- Verificar que la cantidad total (incluyendo la nueva entrada) no exceda la ordenada\n\n  IF (total_registered + NEW.quantity) > order_item_quantity THEN\n\n    RAISE EXCEPTION \n\n      'La cantidad excede lo permitido para este producto en la orden de compra. Cantidad en orden: %, Ya registrado: %, Intentando registrar: %, Total después de esta entrada: %',\n\n      order_item_quantity, \n\n      total_registered, \n\n      NEW.quantity,\n\n      total_registered + NEW.quantity;\n\n  END IF;\n\n\n\n  RETURN NEW;\n\nEND;\n\n"
    },
    {
        "routine_name": "get_period_stats",
        "routine_definition": "\nDECLARE\n    _start_date timestamptz := start_date;\n    _end_date timestamptz := end_date;\n    _period_type text := COALESCE(period_type, 'daily');\n    _trunc_format text;\nBEGIN\n    -- Determinar formato de truncamiento según el tipo de período\n    CASE _period_type\n        WHEN 'daily' THEN _trunc_format := 'day';\n        WHEN 'weekly' THEN _trunc_format := 'week';\n        WHEN 'monthly' THEN _trunc_format := 'month';\n        WHEN 'yearly' THEN _trunc_format := 'year';\n        ELSE _trunc_format := 'day';\n    END CASE;\n\n    RETURN QUERY\n    WITH all_movements AS (\n        -- Entradas\n        SELECT\n            date_trunc(_trunc_format, ie.created_at) AS period,\n            'entry' AS movement_type,\n            ie.quantity,\n            ie.id AS movement_id\n        FROM public.inventory_entries ie\n        WHERE ie.created_at >= _start_date\n          AND ie.created_at <= _end_date\n        \n        UNION ALL\n        \n        -- Salidas\n        SELECT\n            date_trunc(_trunc_format, iex.created_at) AS period,\n            'exit' AS movement_type,\n            iex.quantity,\n            iex.id AS movement_id\n        FROM public.inventory_exits iex\n        WHERE iex.created_at >= _start_date\n          AND iex.created_at <= _end_date\n    ),\n    cancellations AS (\n        -- Cancelaciones de entradas\n        SELECT\n            date_trunc(_trunc_format, iec.created_at) AS period,\n            iec.id\n        FROM public.inventory_entry_cancellations iec\n        WHERE iec.created_at >= _start_date\n          AND iec.created_at <= _end_date\n        \n        UNION ALL\n        \n        -- Cancelaciones de salidas\n        SELECT\n            date_trunc(_trunc_format, iecx.created_at) AS period,\n            iecx.id\n        FROM public.inventory_exit_cancellations iecx\n        WHERE iecx.created_at >= _start_date\n          AND iecx.created_at <= _end_date\n    ),\n    period_series AS (\n        SELECT generate_series(\n            date_trunc(_trunc_format, _start_date),\n            date_trunc(_trunc_format, _end_date),\n            ('1 ' || _trunc_format)::interval\n        ) AS period\n    ),\n    aggregated AS (\n        SELECT\n            ps.period,\n            COUNT(*) FILTER (WHERE am.movement_type = 'entry') AS entries_count,\n            COUNT(*) FILTER (WHERE am.movement_type = 'exit') AS exits_count,\n            COALESCE(SUM(am.quantity) FILTER (WHERE am.movement_type = 'entry'), 0) AS entries_quantity,\n            COALESCE(SUM(am.quantity) FILTER (WHERE am.movement_type = 'exit'), 0) AS exits_quantity,\n            COUNT(DISTINCT c.id) AS cancellations_count\n        FROM period_series ps\n        LEFT JOIN all_movements am ON date_trunc(_trunc_format, am.period) = ps.period\n        LEFT JOIN cancellations c ON c.period = ps.period\n        GROUP BY ps.period\n    )\n    SELECT\n        a.period::date AS period_date,\n        CASE _period_type\n            WHEN 'daily' THEN to_char(a.period, 'DD Mon')\n            WHEN 'weekly' THEN 'Sem ' || to_char(a.period, 'WW')\n            WHEN 'monthly' THEN to_char(a.period, 'Mon YYYY')\n            WHEN 'yearly' THEN to_char(a.period, 'YYYY')\n            ELSE to_char(a.period, 'DD Mon')\n        END AS period_label,\n        a.entries_count,\n        a.exits_count,\n        a.entries_quantity,\n        a.exits_quantity,\n        a.cancellations_count,\n        (a.entries_quantity - a.exits_quantity) AS net_movement\n    FROM aggregated a\n    ORDER BY a.period;\nEND;\n"
    },
    {
        "routine_name": "get_user_activities_today",
        "routine_definition": "\nWITH today_range AS (\n    SELECT\n        date_trunc('day', CURRENT_TIMESTAMP AT TIME ZONE 'America/Bogota') AS start_time,\n        date_trunc('day', CURRENT_TIMESTAMP AT TIME ZONE 'America/Bogota') + INTERVAL '1 day' AS end_time\n),\nuser_movements AS (\n    -- Entradas\n    SELECT\n        ie.created_by AS user_id,\n        'entry' AS movement_type\n    FROM public.inventory_entries ie\n    CROSS JOIN today_range tr\n    WHERE ie.created_at >= tr.start_time\n      AND ie.created_at < tr.end_time\n      AND ie.created_by IS NOT NULL\n    \n    UNION ALL\n    \n    -- Salidas\n    SELECT\n        iex.created_by AS user_id,\n        'exit' AS movement_type\n    FROM public.inventory_exits iex\n    CROSS JOIN today_range tr\n    WHERE iex.created_at >= tr.start_time\n      AND iex.created_at < tr.end_time\n      AND iex.created_by IS NOT NULL\n),\naggregated AS (\n    SELECT\n        um.user_id,\n        COUNT(*) FILTER (WHERE um.movement_type = 'entry') AS entries_count,\n        COUNT(*) FILTER (WHERE um.movement_type = 'exit') AS exits_count,\n        COUNT(*) AS total_movements\n    FROM user_movements um\n    GROUP BY um.user_id\n)\nSELECT\n    a.user_id,\n    COALESCE(p.full_name, 'Usuario sin nombre') AS user_name,\n    p.email AS user_email,\n    a.entries_count,\n    a.exits_count,\n    a.total_movements\nFROM aggregated a\nLEFT JOIN public.profiles p ON p.id = a.user_id\nORDER BY a.total_movements DESC\nLIMIT 10;\n"
    },
    {
        "routine_name": "get_users_stats",
        "routine_definition": "\nWITH base AS (\n    SELECT\n        p.id,\n        p.deleted_at,\n        ARRAY_REMOVE(\n            ARRAY_AGG(LOWER(r.nombre)) FILTER (WHERE r.id IS NOT NULL),\n            NULL\n        ) AS role_names\n    FROM public.profiles p\n    LEFT JOIN public.user_roles ur ON ur.user_id = p.id\n    LEFT JOIN public.roles r ON r.id = ur.role_id AND r.deleted_at IS NULL\n    GROUP BY p.id, p.deleted_at\n)\nSELECT\n    COUNT(*) AS total,\n    COUNT(*) FILTER (WHERE b.deleted_at IS NULL) AS active,\n    COUNT(*) FILTER (WHERE 'admin' = ANY(role_names)) AS admins,\n    COUNT(*) FILTER (WHERE 'bodeguero' = ANY(role_names)) AS bodegueros,\n    COUNT(*) FILTER (WHERE 'vendedor' = ANY(role_names)) AS vendedores\nFROM base b;\n"
    },
    {
        "routine_name": "generate_purchase_order_number",
        "routine_definition": "\nDECLARE\n    order_year INTEGER;\n    next_sequence INTEGER;\n    new_order_number TEXT;\nBEGIN\n    -- Obtener el año de la orden\n    order_year := EXTRACT(YEAR FROM COALESCE(NEW.created_at, NOW()));\n    \n    -- Obtener el siguiente número secuencial del año\n    -- Busca el máximo número que coincida con el patrón OC-YYYY-NNNN\n    SELECT COALESCE(MAX(\n        CAST(SUBSTRING(order_number FROM 'OC-\\d+-(\\d+)') AS INTEGER)\n    ), 0) + 1\n    INTO next_sequence\n    FROM public.purchase_orders\n    WHERE order_number LIKE 'OC-' || order_year || '-%'\n      AND deleted_at IS NULL;\n    \n    -- Generar el número de orden en formato OC-YYYY-NNNN\n    new_order_number := 'OC-' || order_year || '-' || LPAD(next_sequence::TEXT, 4, '0');\n    \n    -- Asignar el número de orden\n    NEW.order_number := new_order_number;\n    \n    RETURN NEW;\nEND;\n"
    },
    {
        "routine_name": "get_products_stats",
        "routine_definition": "\nSELECT\n    COUNT(*) FILTER (WHERE p.deleted_at IS NULL) AS total_products,\n    COUNT(*) FILTER (\n        WHERE p.deleted_at IS NULL\n          AND p.barcode IS NOT NULL\n          AND p.barcode <> ''\n          AND p.barcode NOT ILIKE 'INT-%'\n    ) AS products_with_barcode,\n    COUNT(*) FILTER (\n        WHERE p.deleted_at IS NULL\n          AND p.barcode ILIKE 'INT-%'\n    ) AS products_with_internal_barcode,\n    COUNT(DISTINCT p.category_id) FILTER (\n        WHERE p.deleted_at IS NULL\n          AND p.category_id IS NOT NULL\n    ) AS unique_categories\nFROM public.products p;\n"
    },
    {
        "routine_name": "get_users_dashboard",
        "routine_definition": "\nDECLARE\n    _limit integer := GREATEST(COALESCE(page_size, 5), 1);\n    _offset integer := GREATEST((COALESCE(page, 1) - 1) * _limit, 0);\n    _search text := COALESCE(search_term, '');\nBEGIN\n    RETURN QUERY\n    WITH filtered AS (\n        SELECT\n            p.id,\n            p.email,\n            p.full_name,\n            p.avatar_url,\n            p.deleted_at,\n            p.created_at\n        FROM public.profiles p\n        WHERE (\n            _search = ''\n            OR p.full_name ILIKE '%' || _search || '%'\n            OR p.email ILIKE '%' || _search || '%'\n        )\n    ),\n    enriched AS (\n        SELECT\n            f.*,\n            COALESCE(\n                jsonb_agg(\n                    jsonb_build_object(\n                        'id', r.id,\n                        'nombre', r.nombre\n                    )\n                ) FILTER (WHERE r.id IS NOT NULL),\n                '[]'::jsonb\n            ) AS roles\n        FROM filtered f\n        LEFT JOIN public.user_roles ur ON ur.user_id = f.id\n        LEFT JOIN public.roles r ON r.id = ur.role_id AND r.deleted_at IS NULL\n        GROUP BY\n            f.id,\n            f.email,\n            f.full_name,\n            f.avatar_url,\n            f.deleted_at,\n            f.created_at\n    ),\n    numbered AS (\n        SELECT\n            e.*,\n            COUNT(*) OVER () AS total_count,\n            ROW_NUMBER() OVER (ORDER BY e.deleted_at NULLS FIRST, e.created_at DESC) AS row_number\n        FROM enriched e\n        -- Removido el filtro WHERE e.deleted_at IS NULL para incluir usuarios eliminados\n    )\n    SELECT\n        n.id,\n        n.email,\n        n.full_name,\n        n.avatar_url,\n        n.deleted_at,\n        n.created_at,\n        n.roles,\n        n.total_count\n    FROM numbered n\n    WHERE n.row_number > _offset\n    ORDER BY n.row_number\n    LIMIT _limit;\nEND;\n"
    },
    {
        "routine_name": "handle_updated_at",
        "routine_definition": "\nbegin\n  new.updated_at = now();\n  return new;\nend;\n"
    },
    {
        "routine_name": "update_delivery_orders_updated_at",
        "routine_definition": "\nBEGIN\n    NEW.updated_at = NOW();\n    RETURN NEW;\nEND;\n"
    },
    {
        "routine_name": "update_delivery_status_observation_updated_at",
        "routine_definition": "\nBEGIN\n    NEW.updated_at = NOW();\n    RETURN NEW;\nEND;\n"
    },
    {
        "routine_name": "update_delivery_order_edit_observation_updated_at",
        "routine_definition": "\nBEGIN\n    NEW.updated_at = NOW();\n    RETURN NEW;\nEND;\n"
    },
    {
        "routine_name": "update_delivery_order_return_updated_at",
        "routine_definition": "\nBEGIN\n    NEW.updated_at = NOW();\n    RETURN NEW;\nEND;\n"
    },
    {
        "routine_name": "get_purchase_orders_dashboard",
        "routine_definition": "\nDECLARE\n    _limit integer := GREATEST(COALESCE(page_size, 5), 1);\n    _offset integer := GREATEST((COALESCE(page, 1) - 1) * _limit, 0);\n    _search text := COALESCE(search_term, '');\n    _status_filter text := NULLIF(TRIM(COALESCE(status_filter, '')), '');\nBEGIN\n    RETURN QUERY\n    WITH filtered AS (\n        SELECT\n            po.id,\n            po.status,\n            po.supplier_id,\n            s.name::text AS supplier_name,\n            po.created_at,\n            po.notes,\n            po.order_number\n        FROM public.purchase_orders po\n        LEFT JOIN public.suppliers s ON s.id = po.supplier_id\n        WHERE po.deleted_at IS NULL\n          AND (\n            _search = ''\n            OR po.status ILIKE '%' || _search || '%'\n            OR po.notes ILIKE '%' || _search || '%'\n            OR po.id::text ILIKE '%' || _search || '%'\n            OR po.order_number ILIKE '%' || _search || '%'\n            OR s.name ILIKE '%' || _search || '%'\n          )\n          AND (\n            _status_filter IS NULL\n            OR po.status = _status_filter\n          )\n    ),\n    items AS (\n        SELECT\n            poi.purchase_order_id,\n            SUM(poi.quantity) AS total_quantity,\n            COUNT(*) AS total_items,\n            jsonb_agg(\n                jsonb_build_object(\n                    'product_id', poi.product_id,\n                    'product_name', p.name,\n                    'ordered_quantity', poi.quantity\n                )\n            ) AS items\n        FROM public.purchase_order_items poi\n        LEFT JOIN public.products p ON p.id = poi.product_id\n        GROUP BY poi.purchase_order_id\n    ),\n    entries AS (\n        SELECT\n            ie.purchase_order_id,\n            ie.product_id,\n            SUM(ie.quantity) AS received_quantity\n        FROM public.inventory_entries ie\n        LEFT JOIN public.inventory_entry_cancellations iec ON iec.inventory_entry_id = ie.id\n        WHERE iec.id IS NULL\n        GROUP BY ie.purchase_order_id, ie.product_id\n    ),\n    enriched AS (\n        SELECT\n            f.*,\n            i.total_items,\n            i.total_quantity,\n            i.items,\n            jsonb_agg(\n                jsonb_build_object(\n                    'product_id', item->>'product_id',\n                    'product_name', item->>'product_name',\n                    'ordered_quantity', (item->>'ordered_quantity')::numeric,\n                    'received_quantity', COALESCE(e.received_quantity, 0),\n                    'is_complete', COALESCE(e.received_quantity, 0) >= (item->>'ordered_quantity')::numeric\n                )\n            ) FILTER (WHERE i.items IS NOT NULL) AS completion_detail,\n            (\n                jsonb_build_object(\n                    'isComplete',\n                    CASE\n                        WHEN i.items IS NULL THEN false\n                        ELSE bool_and(COALESCE(e.received_quantity, 0) >= (item->>'ordered_quantity')::numeric)\n                    END,\n                    'totalItems', COALESCE(i.total_items, 0),\n                    'receivedItems',\n                    COALESCE(\n                        SUM(LEAST(COALESCE(e.received_quantity, 0), (item->>'ordered_quantity')::numeric)),\n                        0\n                    )\n                )\n            ) AS completion\n        FROM filtered f\n        LEFT JOIN items i ON i.purchase_order_id = f.id\n        LEFT JOIN LATERAL jsonb_array_elements(i.items) item ON true\n        LEFT JOIN entries e ON e.purchase_order_id = f.id AND e.product_id = (item->>'product_id')::uuid\n        GROUP BY\n            f.id,\n            f.status,\n            f.supplier_id,\n            f.supplier_name,\n            f.created_at,\n            f.notes,\n            f.order_number,\n            i.total_items,\n            i.total_quantity,\n            i.items\n    ),\n    numbered AS (\n        SELECT\n            e.*,\n            COUNT(*) OVER () AS total_count,\n            ROW_NUMBER() OVER (ORDER BY e.created_at DESC) AS row_number\n        FROM enriched e\n    )\n    SELECT\n        n.id,\n        n.status,\n        n.supplier_id,\n        n.supplier_name,\n        n.created_at,\n        n.notes,\n        n.order_number,\n        COALESCE(n.total_items, 0)::numeric AS total_items,\n        COALESCE(n.total_quantity, 0)::numeric AS total_quantity,\n        n.completion,\n        n.completion_detail,\n        n.total_count\n    FROM numbered n\n    WHERE n.row_number > _offset\n    ORDER BY n.row_number\n    LIMIT _limit;\nEND;\n"
    },
    {
        "routine_name": "validate_inventory_exit_quantity",
        "routine_definition": "\n\nDECLARE\n\n  order_item_quantity NUMERIC;\n\n  total_dispatched NUMERIC;\n\n  order_status TEXT;\n\n  order_exists BOOLEAN;\n\nBEGIN\n\n  -- Solo validar si hay una orden de entrega asociada\n\n  IF NEW.delivery_order_id IS NULL THEN\n\n    RETURN NEW;\n\n  END IF;\n\n\n\n  -- Verificar que la orden existe y obtener su estado\n\n  SELECT \n\n    dord.status,\n\n    EXISTS(SELECT 1 FROM delivery_orders WHERE id = NEW.delivery_order_id AND deleted_at IS NULL)\n\n  INTO order_status, order_exists\n\n  FROM delivery_orders dord\n\n  WHERE dord.id = NEW.delivery_order_id\n\n    AND dord.deleted_at IS NULL;\n\n\n\n  IF NOT order_exists THEN\n\n    RAISE EXCEPTION 'La orden de entrega % no existe o ha sido eliminada', NEW.delivery_order_id;\n\n  END IF;\n\n\n\n  -- Verificar que la orden esté en estado válido (no cancelada)\n\n  IF order_status = 'cancelled' THEN\n\n    RAISE EXCEPTION 'La orden de entrega % está cancelada. No se pueden registrar más salidas.', \n\n      NEW.delivery_order_id;\n\n  END IF;\n\n\n\n  -- Obtener la cantidad solicitada para este producto en la orden y bodega específica\n\n  SELECT quantity\n\n  INTO order_item_quantity\n\n  FROM delivery_order_items\n\n  WHERE delivery_order_id = NEW.delivery_order_id\n\n    AND product_id = NEW.product_id\n\n    AND warehouse_id = NEW.warehouse_id;\n\n\n\n  -- Si no hay item en la orden para este producto en esta bodega, rechazar\n\n  IF order_item_quantity IS NULL THEN\n\n    RAISE EXCEPTION 'El producto % no está incluido en la orden de entrega % para la bodega %', \n\n      NEW.product_id, NEW.delivery_order_id, NEW.warehouse_id;\n\n  END IF;\n\n\n\n  -- Calcular la cantidad total ya despachada para este producto en esta orden y bodega\n\n  -- Sumar todas las salidas existentes (excluyendo la actual si es un UPDATE)\n\n  SELECT COALESCE(SUM(quantity), 0)\n\n  INTO total_dispatched\n\n  FROM inventory_exits\n\n  WHERE delivery_order_id = NEW.delivery_order_id\n\n    AND product_id = NEW.product_id\n\n    AND warehouse_id = NEW.warehouse_id\n\n    AND (TG_OP = 'INSERT' OR id != NEW.id); -- Excluir la fila actual si es UPDATE\n\n\n\n  -- Verificar que la cantidad total (incluyendo la nueva salida) no exceda la solicitada\n\n  IF (total_dispatched + NEW.quantity) > order_item_quantity THEN\n\n    RAISE EXCEPTION \n\n      'La cantidad excede lo permitido para este producto en la orden de entrega. Cantidad en orden: %, Ya despachado: %, Intentando despachar: %, Total después de esta salida: %',\n\n      order_item_quantity, \n\n      total_dispatched, \n\n      NEW.quantity,\n\n      total_dispatched + NEW.quantity;\n\n  END IF;\n\n\n\n  RETURN NEW;\n\nEND;\n\n"
    },
    {
        "routine_name": "set_limit",
        "routine_definition": null
    },
    {
        "routine_name": "show_limit",
        "routine_definition": null
    },
    {
        "routine_name": "show_trgm",
        "routine_definition": null
    },
    {
        "routine_name": "similarity",
        "routine_definition": null
    },
    {
        "routine_name": "similarity_op",
        "routine_definition": null
    },
    {
        "routine_name": "word_similarity",
        "routine_definition": null
    },
    {
        "routine_name": "word_similarity_op",
        "routine_definition": null
    },
    {
        "routine_name": "word_similarity_commutator_op",
        "routine_definition": null
    },
    {
        "routine_name": "similarity_dist",
        "routine_definition": null
    },
    {
        "routine_name": "word_similarity_dist_op",
        "routine_definition": null
    },
    {
        "routine_name": "word_similarity_dist_commutator_op",
        "routine_definition": null
    },
    {
        "routine_name": "gtrgm_in",
        "routine_definition": null
    },
    {
        "routine_name": "gtrgm_out",
        "routine_definition": null
    },
    {
        "routine_name": "gtrgm_consistent",
        "routine_definition": null
    },
    {
        "routine_name": "gtrgm_distance",
        "routine_definition": null
    },
    {
        "routine_name": "gtrgm_compress",
        "routine_definition": null
    },
    {
        "routine_name": "gtrgm_decompress",
        "routine_definition": null
    },
    {
        "routine_name": "gtrgm_penalty",
        "routine_definition": null
    },
    {
        "routine_name": "gtrgm_picksplit",
        "routine_definition": null
    },
    {
        "routine_name": "gtrgm_union",
        "routine_definition": null
    },
    {
        "routine_name": "gtrgm_same",
        "routine_definition": null
    },
    {
        "routine_name": "gin_extract_value_trgm",
        "routine_definition": null
    },
    {
        "routine_name": "gin_extract_query_trgm",
        "routine_definition": null
    },
    {
        "routine_name": "gin_trgm_consistent",
        "routine_definition": null
    },
    {
        "routine_name": "get_inventory_entries_dashboard",
        "routine_definition": "\nDECLARE\n    _limit integer := GREATEST(COALESCE(page_size, 5), 1);\n    _offset integer := GREATEST((COALESCE(page, 1) - 1) * _limit, 0);\n    _search text := COALESCE(LOWER(TRIM(search_term)), '');\nBEGIN\n    RETURN QUERY\n    WITH filtered AS (\n        SELECT\n            ie.id,\n            ie.product_id,\n            ie.warehouse_id,\n            ie.supplier_id,\n            ie.purchase_order_id,\n            ie.quantity,\n            ie.entry_type,\n            ie.barcode_scanned,\n            ie.created_by,\n            ie.created_at,\n            p.name AS product_name,\n            p.sku AS product_sku,\n            p.barcode AS product_barcode,\n            w.name AS warehouse_name,\n            s.name AS supplier_name,\n            pr.full_name AS created_by_name,\n            iec.id AS cancellation_id,\n            iec.observations AS cancellation_observations,\n            iec.created_at AS cancellation_created_at\n        FROM public.inventory_entries ie\n        LEFT JOIN public.products p ON p.id = ie.product_id\n        LEFT JOIN public.warehouses w ON w.id = ie.warehouse_id\n        LEFT JOIN public.suppliers s ON s.id = ie.supplier_id\n        LEFT JOIN public.profiles pr ON pr.id = ie.created_by\n        LEFT JOIN public.inventory_entry_cancellations iec ON iec.inventory_entry_id = ie.id\n        WHERE (\n            _search = ''\n            OR LOWER(p.name) LIKE '%' || _search || '%'\n            OR LOWER(p.sku) LIKE '%' || _search || '%'\n            OR LOWER(p.barcode) LIKE '%' || _search || '%'\n            OR LOWER(w.name) LIKE '%' || _search || '%'\n            OR LOWER(s.name) LIKE '%' || _search || '%'\n            OR LOWER(pr.full_name) LIKE '%' || _search || '%'\n            OR LOWER(ie.entry_type) LIKE '%' || _search || '%'\n            OR LOWER(ie.barcode_scanned) LIKE '%' || _search || '%'\n            OR ie.purchase_order_id::text LIKE '%' || _search || '%'\n        )\n    ),\n    numbered AS (\n        SELECT\n            f.*,\n            COUNT(*) OVER () AS total_count,\n            ROW_NUMBER() OVER (ORDER BY f.created_at DESC) AS row_number\n        FROM filtered f\n    )\n    SELECT\n        n.id,\n        n.product_id,\n        n.product_name::text,\n        n.product_sku::text,\n        n.product_barcode::text,\n        n.warehouse_id,\n        n.warehouse_name::text,\n        n.supplier_id,\n        n.supplier_name::text,\n        n.purchase_order_id,\n        n.quantity,\n        n.entry_type::text,\n        n.barcode_scanned::text,\n        n.created_by,\n        n.created_by_name::text,\n        n.created_at,\n        (n.cancellation_id IS NOT NULL) AS is_cancelled,\n        n.cancellation_id,\n        n.cancellation_observations::text,\n        n.cancellation_created_at,\n        n.total_count\n    FROM numbered n\n    WHERE n.row_number > _offset\n    ORDER BY n.row_number\n    LIMIT _limit;\nEND;\n"
    },
    {
        "routine_name": "gin_trgm_triconsistent",
        "routine_definition": null
    },
    {
        "routine_name": "strict_word_similarity",
        "routine_definition": null
    },
    {
        "routine_name": "strict_word_similarity_op",
        "routine_definition": null
    },
    {
        "routine_name": "strict_word_similarity_commutator_op",
        "routine_definition": null
    },
    {
        "routine_name": "strict_word_similarity_dist_op",
        "routine_definition": null
    },
    {
        "routine_name": "strict_word_similarity_dist_commutator_op",
        "routine_definition": null
    },
    {
        "routine_name": "gtrgm_options",
        "routine_definition": null
    },
    {
        "routine_name": "get_delivery_orders_dashboard",
        "routine_definition": "\nDECLARE\n    _limit integer := GREATEST(COALESCE(page_size, 5), 1);\n    _offset integer := GREATEST((COALESCE(page, 1) - 1) * _limit, 0);\n    _search text := COALESCE(LOWER(TRIM(search_term)), '');\nBEGIN\n    RETURN QUERY\n    WITH filtered AS (\n        SELECT\n            dord.id,\n            dord.customer_id,\n            dord.status,\n            dord.notes,\n            dord.delivery_address,\n            dord.created_at,\n            dord.created_by,\n            c.name AS customer_name,\n            c.id_number AS customer_id_number\n        FROM public.delivery_orders dord\n        LEFT JOIN public.customers c ON c.id = dord.customer_id\n        WHERE dord.deleted_at IS NULL\n          AND (\n            _search = ''\n            OR dord.status ILIKE '%' || _search || '%'\n            OR dord.notes ILIKE '%' || _search || '%'\n            OR dord.id::text ILIKE '%' || _search || '%'\n            OR LOWER(c.name) LIKE '%' || _search || '%'\n            OR LOWER(c.id_number) LIKE '%' || _search || '%'\n          )\n    ),\n    items_agg AS (\n        SELECT\n            doi.delivery_order_id,\n            COUNT(*)::bigint AS total_items,\n            SUM(doi.quantity)::numeric AS total_quantity,\n            COUNT(*) FILTER (WHERE doi.delivered_quantity >= doi.quantity)::bigint AS delivered_items,\n            SUM(doi.delivered_quantity)::numeric AS delivered_quantity,\n            jsonb_agg(\n                jsonb_build_object(\n                    'product_id', doi.product_id,\n                    'product_name', p.name,\n                    'quantity', doi.quantity,\n                    'delivered_quantity', doi.delivered_quantity,\n                    'warehouse_id', doi.warehouse_id,\n                    'warehouse_name', w.name\n                )\n            ) AS items\n        FROM public.delivery_order_items doi\n        LEFT JOIN public.products p ON p.id = doi.product_id\n        LEFT JOIN public.warehouses w ON w.id = doi.warehouse_id\n        GROUP BY doi.delivery_order_id\n    ),\n    enriched AS (\n        SELECT\n            f.*,\n            pr.full_name AS created_by_name,\n            COALESCE(ia.total_items, 0)::bigint AS total_items,\n            COALESCE(ia.total_quantity, 0)::numeric AS total_quantity,\n            COALESCE(ia.delivered_items, 0)::bigint AS delivered_items,\n            COALESCE(ia.delivered_quantity, 0)::numeric AS delivered_quantity,\n            COALESCE(ia.items, '[]'::jsonb) AS items\n        FROM filtered f\n        LEFT JOIN public.profiles pr ON pr.id = f.created_by\n        LEFT JOIN items_agg ia ON ia.delivery_order_id = f.id\n    ),\n    numbered AS (\n        SELECT\n            e.*,\n            COUNT(*) OVER () AS total_count,\n            ROW_NUMBER() OVER (ORDER BY e.created_at DESC) AS row_number\n        FROM enriched e\n    )\n    SELECT\n        n.id,\n        n.customer_id,\n        n.customer_name::text,\n        n.customer_id_number::text,\n        n.status::text,\n        n.notes::text,\n        n.delivery_address::text,\n        n.created_at,\n        n.created_by,\n        n.created_by_name::text,\n        n.total_items,\n        n.total_quantity,\n        n.delivered_items,\n        n.delivered_quantity,\n        n.items,\n        n.total_count\n    FROM numbered n\n    WHERE n.row_number > _offset\n    ORDER BY n.row_number\n    LIMIT _limit;\nEND;\n"
    },
    {
        "routine_name": "get_delivery_orders_stats",
        "routine_definition": "\nWITH order_stats AS (\n    SELECT\n        dord.id,\n        dord.status,\n        COUNT(doi.id) AS item_count,\n        SUM(doi.quantity - doi.delivered_quantity) AS pending_quantity\n    FROM public.delivery_orders dord\n    LEFT JOIN public.delivery_order_items doi ON doi.delivery_order_id = dord.id\n    WHERE dord.deleted_at IS NULL\n    GROUP BY dord.id, dord.status\n)\nSELECT\n    COUNT(*) AS total_orders,\n    COUNT(*) FILTER (WHERE status = 'pending') AS pending_orders,\n    COUNT(*) FILTER (WHERE status = 'preparing') AS preparing_orders,\n    COUNT(*) FILTER (WHERE status = 'ready') AS ready_orders,\n    COUNT(*) FILTER (WHERE status = 'delivered') AS delivered_orders,\n    COUNT(*) FILTER (WHERE status = 'cancelled') AS cancelled_orders,\n    COUNT(*) FILTER (WHERE status IN ('pending', 'preparing', 'ready') AND pending_quantity > 0) AS total_items_pending,\n    COALESCE(SUM(pending_quantity) FILTER (WHERE status IN ('pending', 'preparing', 'ready')), 0)::numeric AS total_quantity_pending\nFROM order_stats;\n"
    },
    {
        "routine_name": "get_product_traceability",
        "routine_definition": "\nDECLARE\n    _product_ids uuid[];\n    _search text := COALESCE(LOWER(TRIM(search_term)), '');\nBEGIN\n    -- Si se proporcionan product_ids, usarlos\n    IF product_ids IS NOT NULL AND array_length(product_ids, 1) > 0 THEN\n        _product_ids := product_ids;\n    -- Si hay término de búsqueda, buscar productos\n    ELSIF _search <> '' THEN\n        SELECT array_agg(p.id)\n        INTO _product_ids\n        FROM (\n            SELECT id\n            FROM public.products\n            WHERE deleted_at IS NULL\n              AND (\n                LOWER(name) LIKE '%' || _search || '%'\n                OR LOWER(sku) LIKE '%' || _search || '%'\n                OR LOWER(barcode) LIKE '%' || _search || '%'\n              )\n            LIMIT products_limit\n        ) p;\n    -- Si no hay filtros, obtener productos con movimientos recientes\n    ELSE\n        WITH recent_products AS (\n            (SELECT ie.product_id, ie.created_at\n             FROM public.inventory_entries ie\n             ORDER BY ie.created_at DESC\n             LIMIT products_limit * 2)\n            \n            UNION\n            \n            (SELECT iex.product_id, iex.created_at\n             FROM public.inventory_exits iex\n             ORDER BY iex.created_at DESC\n             LIMIT products_limit * 2)\n        )\n        SELECT array_agg(DISTINCT limited.product_id)\n        INTO _product_ids\n        FROM (\n            SELECT rp.product_id, rp.created_at\n            FROM recent_products rp\n            ORDER BY rp.created_at DESC\n            LIMIT products_limit\n        ) limited;\n    END IF;\n\n    -- Si no hay productos, retornar vacío\n    IF _product_ids IS NULL OR array_length(_product_ids, 1) = 0 THEN\n        RETURN;\n    END IF;\n\n    RETURN QUERY\n    WITH product_events AS (\n        -- Entradas\n        SELECT\n            ie.product_id,\n            jsonb_build_object(\n                'id', ie.id,\n                'type', 'entry',\n                'date', ie.created_at,\n                'description', CASE\n                    WHEN ie.purchase_order_id IS NOT NULL\n                    THEN 'Recibido (OC-' || SUBSTRING(ie.purchase_order_id::text, 1, 8) || '...)'\n                    ELSE 'Recibido'\n                END,\n                'user', COALESCE(pr.full_name, NULL),\n                'warehouse', w.name,\n                'purchaseOrder', ie.purchase_order_id,\n                'quantity', ie.quantity\n            ) AS event,\n            ie.created_at AS event_date\n        FROM public.inventory_entries ie\n        LEFT JOIN public.profiles pr ON pr.id = ie.created_by\n        LEFT JOIN public.warehouses w ON w.id = ie.warehouse_id\n        WHERE ie.product_id = ANY(_product_ids)\n        \n        UNION ALL\n        \n        -- Salidas\n        SELECT\n            iex.product_id,\n            jsonb_build_object(\n                'id', iex.id,\n                'type', 'exit',\n                'date', iex.created_at,\n                'description', 'Despachado',\n                'user', COALESCE(pr.full_name, NULL),\n                'warehouse', w.name,\n                'purchaseOrder', NULL,\n                'quantity', iex.quantity\n            ) AS event,\n            iex.created_at AS event_date\n        FROM public.inventory_exits iex\n        LEFT JOIN public.profiles pr ON pr.id = iex.created_by\n        LEFT JOIN public.warehouses w ON w.id = iex.warehouse_id\n        WHERE iex.product_id = ANY(_product_ids)\n    ),\n    ranked_events AS (\n        SELECT\n            pe.product_id,\n            pe.event,\n            ROW_NUMBER() OVER (PARTITION BY pe.product_id ORDER BY pe.event_date DESC) AS rn\n        FROM product_events pe\n    ),\n    aggregated_events AS (\n        SELECT\n            re.product_id,\n            jsonb_agg(re.event ORDER BY (re.event->>'date')::timestamptz DESC) AS events\n        FROM ranked_events re\n        WHERE re.rn <= events_limit\n        GROUP BY re.product_id\n    )\n    SELECT\n        p.id AS product_id,\n        p.name AS product_name,\n        p.sku AS product_sku,\n        p.barcode AS product_barcode,\n        COALESCE(ae.events, '[]'::jsonb) AS events\n    FROM public.products p\n    LEFT JOIN aggregated_events ae ON ae.product_id = p.id\n    WHERE p.id = ANY(_product_ids)\n      AND p.deleted_at IS NULL;\nEND;\n"
    },
    {
        "routine_name": "get_customer_delivery_orders",
        "routine_definition": "\nDECLARE\n    offset_val integer;\nBEGIN\n    offset_val := GREATEST((COALESCE(page, 1) - 1) * COALESCE(page_size, 50), 0);\n    \n    RETURN QUERY\n    WITH total AS (\n        SELECT COUNT(*)::bigint AS cnt\n        FROM public.delivery_orders dord\n        WHERE dord.customer_id = customer_id_param\n          AND dord.deleted_at IS NULL\n    ),\n    items_agg AS (\n        SELECT\n            doi.delivery_order_id,\n            COUNT(*)::bigint AS total_items,\n            SUM(doi.quantity)::numeric AS total_quantity,\n            SUM(doi.delivered_quantity)::numeric AS delivered_quantity\n        FROM public.delivery_order_items doi\n        GROUP BY doi.delivery_order_id\n    ),\n    enriched AS (\n        SELECT\n            dord.id,\n            dord.status,\n            dord.notes,\n            dord.delivery_address,\n            dord.created_at,\n            pr.full_name AS created_by_name,\n            COALESCE(ia.total_items, 0)::bigint AS total_items,\n            COALESCE(ia.total_quantity, 0)::numeric AS total_quantity,\n            COALESCE(ia.delivered_quantity, 0)::numeric AS delivered_quantity,\n            CASE\n                WHEN COALESCE(ia.total_items, 0) = 0 THEN false\n                ELSE (\n                    SELECT bool_and(doi2.delivered_quantity >= doi2.quantity)\n                    FROM public.delivery_order_items doi2\n                    WHERE doi2.delivery_order_id = dord.id\n                )\n            END AS is_complete\n        FROM public.delivery_orders dord\n        LEFT JOIN public.profiles pr ON pr.id = dord.created_by\n        LEFT JOIN items_agg ia ON ia.delivery_order_id = dord.id\n        WHERE dord.customer_id = customer_id_param\n          AND dord.deleted_at IS NULL\n    )\n    SELECT\n        e.id,\n        e.status::text,\n        e.notes::text,\n        e.delivery_address::text,\n        e.created_at,\n        e.created_by_name::text,\n        e.total_items,\n        e.total_quantity,\n        e.delivered_quantity,\n        COALESCE(e.is_complete, false) AS is_complete,\n        total.cnt AS total_count\n    FROM enriched e\n    CROSS JOIN total\n    ORDER BY e.created_at DESC\n    LIMIT GREATEST(COALESCE(page_size, 50), 1)\n    OFFSET offset_val;\nEND;\n"
    },
    {
        "routine_name": "fn_validate_inventory_entry",
        "routine_definition": "\nbegin\n  -- Validación: si tiene purchase_order_id → entry_type debe ser PO_ENTRY\n  if NEW.purchase_order_id is not null and NEW.entry_type <> 'PO_ENTRY' then\n    raise exception 'Si purchase_order_id no es NULL, entry_type debe ser PO_ENTRY';\n  end if;\n\n  -- Validación: si entry_type es PO_ENTRY → debe tener purchase_order_id\n  if NEW.entry_type = 'PO_ENTRY' and NEW.purchase_order_id is null then\n    raise exception 'Las entradas de tipo PO_ENTRY deben tener purchase_order_id';\n  end if;\n\n  -- Validación: si existe supplier_id → debe ser PO_ENTRY o ENTRY normal\n  if NEW.supplier_id is null and NEW.entry_type = 'PO_ENTRY' then\n    raise exception 'Una entrada PO_ENTRY debe tener supplier_id';\n  end if;\n\n  -- Validación: códigos de barras opcionales, sin restricción\n\n  -- Validación cantidad positiva\n  if NEW.quantity <= 0 then\n    raise exception 'La cantidad debe ser mayor a 0';\n  end if;\n\n  return NEW;\nend;\n"
    },
    {
        "routine_name": "update_colors_updated_at",
        "routine_definition": "\nBEGIN\n    NEW.updated_at = NOW();\n    RETURN NEW;\nEND;\n"
    },
    {
        "routine_name": "get_inventory_exits_stats",
        "routine_definition": "\nWITH exits AS (\n    SELECT\n        ie.id,\n        ie.quantity,\n        ie.warehouse_id,\n        iec.id AS cancellation_id\n    FROM public.inventory_exits ie\n    LEFT JOIN public.inventory_exit_cancellations iec ON iec.inventory_exit_id = ie.id\n)\nSELECT\n    COUNT(*) AS total_exits,\n    COALESCE(SUM(quantity), 0) AS total_quantity,\n    COUNT(DISTINCT warehouse_id) AS unique_warehouses,\n    COUNT(*) FILTER (WHERE cancellation_id IS NULL) AS active_exits,\n    COUNT(*) FILTER (WHERE cancellation_id IS NOT NULL) AS cancelled_exits\nFROM exits;\n"
    },
    {
        "routine_name": "update_status_observation_updated_at",
        "routine_definition": "\nBEGIN\n    NEW.updated_at = NOW();\n    RETURN NEW;\nEND;\n"
    },
    {
        "routine_name": "update_returns_updated_at",
        "routine_definition": "\nBEGIN\n    NEW.updated_at = NOW();\n    RETURN NEW;\nEND;\n"
    },
    {
        "routine_name": "validate_return_quantity",
        "routine_definition": "\nDECLARE\n    max_quantity NUMERIC;\n    total_returned NUMERIC;\n    order_exists BOOLEAN;\nBEGIN\n    -- Validar según el tipo de devolución\n    IF NEW.return_type = 'purchase_order' THEN\n        -- Validar que la orden de compra existe\n        SELECT EXISTS(\n            SELECT 1 FROM purchase_orders \n            WHERE id = NEW.order_id AND deleted_at IS NULL\n        ) INTO order_exists;\n        \n        IF NOT order_exists THEN\n            RAISE EXCEPTION 'La orden de compra % no existe o ha sido eliminada', NEW.order_id;\n        END IF;\n        \n        -- Obtener la cantidad recibida para este producto en esta orden\n        -- Sumar todas las entradas de inventario relacionadas con esta orden\n        SELECT COALESCE(SUM(quantity), 0)\n        INTO max_quantity\n        FROM inventory_entries\n        WHERE purchase_order_id = NEW.order_id\n          AND product_id = NEW.product_id\n          AND warehouse_id = NEW.warehouse_id;\n        \n        -- Verificar que el producto esté en la orden\n        IF NOT EXISTS (\n            SELECT 1 FROM purchase_order_items\n            WHERE purchase_order_id = NEW.order_id\n              AND product_id = NEW.product_id\n        ) THEN\n            RAISE EXCEPTION 'El producto % no está incluido en la orden de compra %', \n                NEW.product_id, NEW.order_id;\n        END IF;\n        \n    ELSIF NEW.return_type = 'delivery_order' THEN\n        -- Validar que la orden de entrega existe\n        SELECT EXISTS(\n            SELECT 1 FROM delivery_orders \n            WHERE id = NEW.order_id AND deleted_at IS NULL\n        ) INTO order_exists;\n        \n        IF NOT order_exists THEN\n            RAISE EXCEPTION 'La orden de entrega % no existe o ha sido eliminada', NEW.order_id;\n        END IF;\n        \n        -- Obtener la cantidad entregada para este producto en esta orden y bodega\n        SELECT COALESCE(SUM(quantity), 0)\n        INTO max_quantity\n        FROM inventory_exits\n        WHERE delivery_order_id = NEW.order_id\n          AND product_id = NEW.product_id\n          AND warehouse_id = NEW.warehouse_id;\n        \n        -- Verificar que el producto esté en la orden\n        IF NOT EXISTS (\n            SELECT 1 FROM delivery_order_items\n            WHERE delivery_order_id = NEW.order_id\n              AND product_id = NEW.product_id\n              AND warehouse_id = NEW.warehouse_id\n        ) THEN\n            RAISE EXCEPTION 'El producto % no está incluido en la orden de entrega % para la bodega %', \n                NEW.product_id, NEW.order_id, NEW.warehouse_id;\n        END IF;\n        \n        -- Si hay inventory_exit_id, validar que pertenece a esta orden\n        IF NEW.inventory_exit_id IS NOT NULL THEN\n            IF NOT EXISTS (\n                SELECT 1 FROM inventory_exits\n                WHERE id = NEW.inventory_exit_id\n                  AND delivery_order_id = NEW.order_id\n                  AND product_id = NEW.product_id\n                  AND warehouse_id = NEW.warehouse_id\n            ) THEN\n                RAISE EXCEPTION 'La salida de inventario % no pertenece a esta orden de entrega o producto', \n                    NEW.inventory_exit_id;\n            END IF;\n        END IF;\n    ELSE\n        RAISE EXCEPTION 'Tipo de devolución inválido: %', NEW.return_type;\n    END IF;\n    \n    -- Calcular la cantidad total ya devuelta (excluyendo la actual si es UPDATE)\n    SELECT COALESCE(SUM(quantity), 0)\n    INTO total_returned\n    FROM returns\n    WHERE return_type = NEW.return_type\n      AND order_id = NEW.order_id\n      AND product_id = NEW.product_id\n      AND warehouse_id = NEW.warehouse_id\n      AND (TG_OP = 'INSERT' OR id != NEW.id); -- Excluir la fila actual si es UPDATE\n    \n    -- Validar que la cantidad total devuelta no exceda lo recibido/entregado\n    IF (total_returned + NEW.quantity) > max_quantity THEN\n        RAISE EXCEPTION \n            'La cantidad excede lo permitido para este producto. Máximo disponible: %, Ya devuelto: %, Intentando devolver: %, Total después de esta devolución: %',\n            max_quantity, \n            total_returned, \n            NEW.quantity,\n            total_returned + NEW.quantity;\n    END IF;\n    \n    RETURN NEW;\nEND;\n"
    },
    {
        "routine_name": "get_inventory_exits_dashboard",
        "routine_definition": "\nDECLARE\n    _limit integer := GREATEST(COALESCE(page_size, 5), 1);\n    _offset integer := GREATEST((COALESCE(page, 1) - 1) * _limit, 0);\n    _search text := COALESCE(LOWER(TRIM(search_term)), '');\nBEGIN\n    RETURN QUERY\n    WITH filtered AS (\n        SELECT\n            ie.id,\n            ie.product_id,\n            ie.warehouse_id,\n            ie.quantity,\n            ie.barcode_scanned,\n            ie.created_by,\n            ie.created_at,\n            ie.delivery_order_id,\n            ie.delivery_observations,\n            ie.delivered_to_customer_id,\n            ie.delivered_to_user_id,\n            p.name AS product_name,\n            p.sku AS product_sku,\n            p.barcode AS product_barcode,\n            w.name AS warehouse_name,\n            pr.full_name AS created_by_name,\n            iec.id AS cancellation_id,\n            iec.observations AS cancellation_observations,\n            iec.created_at AS cancellation_created_at,\n            -- Información de \"Entregado a\"\n            CASE\n                WHEN ie.delivered_to_customer_id IS NOT NULL THEN c.name\n                WHEN ie.delivered_to_user_id IS NOT NULL THEN pr_delivered.full_name\n                ELSE NULL\n            END AS delivered_to_name,\n            CASE\n                WHEN ie.delivered_to_customer_id IS NOT NULL THEN c.id_number\n                ELSE NULL\n            END AS delivered_to_id_number,\n            CASE\n                WHEN ie.delivered_to_customer_id IS NOT NULL THEN 'customer'::text\n                WHEN ie.delivered_to_user_id IS NOT NULL THEN 'user'::text\n                ELSE NULL\n            END AS delivered_to_type\n        FROM public.inventory_exits ie\n        LEFT JOIN public.products p ON p.id = ie.product_id\n        LEFT JOIN public.warehouses w ON w.id = ie.warehouse_id\n        LEFT JOIN public.profiles pr ON pr.id = ie.created_by\n        LEFT JOIN public.inventory_exit_cancellations iec ON iec.inventory_exit_id = ie.id\n        LEFT JOIN public.customers c ON c.id = ie.delivered_to_customer_id AND c.deleted_at IS NULL\n        LEFT JOIN public.profiles pr_delivered ON pr_delivered.id = ie.delivered_to_user_id\n        WHERE (\n            _search = ''\n            OR LOWER(p.name) LIKE '%' || _search || '%'\n            OR LOWER(p.sku) LIKE '%' || _search || '%'\n            OR LOWER(p.barcode) LIKE '%' || _search || '%'\n            OR LOWER(w.name) LIKE '%' || _search || '%'\n            OR LOWER(pr.full_name) LIKE '%' || _search || '%'\n            OR LOWER(ie.barcode_scanned) LIKE '%' || _search || '%'\n            OR LOWER(COALESCE(c.name, '')) LIKE '%' || _search || '%'\n            OR LOWER(COALESCE(pr_delivered.full_name, '')) LIKE '%' || _search || '%'\n        )\n    ),\n    numbered AS (\n        SELECT\n            f.*,\n            COUNT(*) OVER () AS total_count,\n            ROW_NUMBER() OVER (ORDER BY f.created_at DESC) AS row_number\n        FROM filtered f\n    )\n    SELECT\n        n.id,\n        n.product_id,\n        n.product_name::text,\n        n.product_sku::text,\n        n.product_barcode::text,\n        n.warehouse_id,\n        n.warehouse_name::text,\n        n.quantity,\n        n.barcode_scanned::text,\n        n.created_by,\n        n.created_by_name::text,\n        n.created_at,\n        (n.cancellation_id IS NOT NULL) AS is_cancelled,\n        n.cancellation_id,\n        n.cancellation_observations::text,\n        n.cancellation_created_at,\n        n.delivery_order_id,\n        n.delivery_observations,\n        n.delivered_to_name::text,\n        n.delivered_to_id_number::text,\n        n.delivered_to_type::text,\n        n.total_count\n    FROM numbered n\n    WHERE n.row_number > _offset\n    ORDER BY n.row_number\n    LIMIT _limit;\nEND;\n"
    },
    {
        "routine_name": "process_return_inventory",
        "routine_definition": "\nDECLARE\n    new_entry_id UUID;\nBEGIN\n    -- Solo procesar en INSERT\n    IF TG_OP = 'INSERT' THEN\n        IF NEW.return_type = 'purchase_order' THEN\n            -- Para purchase orders: crear entrada de inventario (registro de devolución)\n            INSERT INTO inventory_entries (\n                product_id,\n                warehouse_id,\n                quantity,\n                entry_type,\n                purchase_order_id,\n                created_by\n            ) VALUES (\n                NEW.product_id,\n                NEW.warehouse_id,\n                NEW.quantity,\n                'return',\n                NEW.order_id,\n                NEW.created_by\n            )\n            RETURNING id INTO new_entry_id;\n            \n            -- Actualizar stock (RESTAR la cantidad devuelta porque sale del inventario)\n            -- Verificar que existe stock suficiente antes de restar\n            UPDATE warehouse_stock\n            SET \n                quantity = GREATEST(0, quantity - NEW.quantity),\n                updated_at = NOW()\n            WHERE product_id = NEW.product_id\n              AND warehouse_id = NEW.warehouse_id;\n            \n            -- Si no existe registro de stock, no crear uno (no debería pasar si hay productos recibidos)\n            -- Pero por seguridad, si no existe, no hacer nada (el stock ya sería 0 o negativo)\n            \n            -- Actualizar el registro de devolución con el ID de la entrada\n            UPDATE returns\n            SET inventory_entry_id = new_entry_id\n            WHERE id = NEW.id;\n                \n        ELSIF NEW.return_type = 'delivery_order' THEN\n            -- Para delivery orders: crear entrada de inventario (devolver al stock)\n            INSERT INTO inventory_entries (\n                product_id,\n                warehouse_id,\n                quantity,\n                entry_type,\n                created_by\n            ) VALUES (\n                NEW.product_id,\n                NEW.warehouse_id,\n                NEW.quantity,\n                'return',\n                NEW.created_by\n            )\n            RETURNING id INTO new_entry_id;\n            \n            -- Actualizar stock (sumar la cantidad devuelta porque vuelve al inventario)\n            INSERT INTO warehouse_stock (product_id, warehouse_id, quantity, updated_at)\n            VALUES (NEW.product_id, NEW.warehouse_id, NEW.quantity, NOW())\n            ON CONFLICT (product_id, warehouse_id)\n            DO UPDATE SET \n                quantity = warehouse_stock.quantity + NEW.quantity,\n                updated_at = NOW();\n            \n            -- Actualizar delivered_quantity en delivery_order_items (reducir cantidad entregada)\n            UPDATE delivery_order_items\n            SET delivered_quantity = GREATEST(0, delivered_quantity - NEW.quantity)\n            WHERE delivery_order_id = NEW.order_id\n              AND product_id = NEW.product_id\n              AND warehouse_id = NEW.warehouse_id;\n            \n            -- Actualizar el registro de devolución con el ID de la entrada\n            UPDATE returns\n            SET inventory_entry_id = new_entry_id\n            WHERE id = NEW.id;\n        END IF;\n    END IF;\n    \n    RETURN NEW;\nEND;\n"
    },
    {
        "routine_name": "get_returns_dashboard",
        "routine_definition": "\nDECLARE\n    _limit integer := GREATEST(COALESCE(page_size, 50), 1);\n    _offset integer := GREATEST((COALESCE(page, 1) - 1) * _limit, 0);\n    _search text := COALESCE(LOWER(TRIM(search_term)), '');\n    _return_type text := NULLIF(TRIM(COALESCE(return_type_filter, '')), '');\nBEGIN\n    RETURN QUERY\n    WITH filtered AS (\n        SELECT\n            r.id,\n            r.return_type,\n            r.order_id,\n            r.product_id,\n            r.warehouse_id,\n            r.quantity,\n            r.return_reason,\n            r.observations,\n            r.created_by,\n            r.created_at,\n            r.inventory_entry_id,\n            -- Obtener order_number según el tipo usando CASE y LEFT JOIN\n            CASE \n                WHEN r.return_type = 'purchase_order' THEN po.order_number\n                WHEN r.return_type = 'delivery_order' THEN dord.order_number\n                ELSE NULL\n            END AS order_number,\n            -- Información del producto\n            p.name AS product_name,\n            p.sku AS product_sku,\n            -- Información de la bodega\n            w.name AS warehouse_name,\n            -- Información del usuario\n            pr.full_name AS created_by_name\n        FROM public.returns r\n        LEFT JOIN public.products p ON p.id = r.product_id\n        LEFT JOIN public.warehouses w ON w.id = r.warehouse_id\n        LEFT JOIN public.profiles pr ON pr.id = r.created_by\n        LEFT JOIN public.purchase_orders po ON po.id = r.order_id AND r.return_type = 'purchase_order'\n        LEFT JOIN public.delivery_orders dord ON dord.id = r.order_id AND r.return_type = 'delivery_order'\n        WHERE (\n            _return_type IS NULL OR r.return_type = _return_type\n        )\n        AND (\n            _search = ''\n            OR LOWER(r.return_reason) LIKE '%' || _search || '%'\n            OR LOWER(p.name) LIKE '%' || _search || '%'\n            OR LOWER(p.sku) LIKE '%' || _search || '%'\n            OR LOWER(w.name) LIKE '%' || _search || '%'\n        )\n    ),\n    numbered AS (\n        SELECT\n            f.*,\n            COUNT(*) OVER () AS total_count,\n            ROW_NUMBER() OVER (ORDER BY f.created_at DESC) AS row_number\n        FROM filtered f\n    )\n    SELECT\n        n.id,\n        n.return_type::text,\n        n.order_id,\n        n.order_number::text,\n        n.product_id,\n        n.product_name::text,\n        n.product_sku::text,\n        n.warehouse_id,\n        n.warehouse_name::text,\n        n.quantity,\n        n.return_reason::text,\n        n.observations::text,\n        n.created_by,\n        n.created_by_name::text,\n        n.created_at,\n        n.inventory_entry_id,\n        n.total_count\n    FROM numbered n\n    WHERE n.row_number > _offset\n    ORDER BY n.row_number\n    LIMIT _limit;\nEND;\n"
    },
    {
        "routine_name": "get_purchase_orders_stats",
        "routine_definition": "\nWITH orders AS (\n    SELECT\n        po.id,\n        po.status\n    FROM public.purchase_orders po\n    WHERE po.deleted_at IS NULL\n),\nitems AS (\n    SELECT\n        poi.purchase_order_id,\n        SUM(poi.quantity) AS total_quantity,\n        COUNT(*) AS total_items\n    FROM public.purchase_order_items poi\n    INNER JOIN public.purchase_orders po ON po.id = poi.purchase_order_id\n    WHERE po.deleted_at IS NULL\n    GROUP BY poi.purchase_order_id\n)\nSELECT\n    COUNT(*) AS total,\n    COUNT(*) FILTER (WHERE o.status = 'pending') AS pending,\n    COUNT(*) FILTER (WHERE o.status = 'approved') AS approved,\n    COUNT(*) FILTER (WHERE o.status = 'received') AS received,\n    COUNT(*) FILTER (WHERE o.status = 'cancelled') AS cancelled,\n    COALESCE(SUM(i.total_items), 0) AS total_items,\n    COALESCE(SUM(i.total_quantity), 0) AS total_quantity\nFROM orders o\nLEFT JOIN items i ON i.purchase_order_id = o.id;\n"
    },
    {
        "routine_name": "get_purchase_orders_dashboard",
        "routine_definition": "\nDECLARE\n    _limit integer := GREATEST(COALESCE(page_size, 5), 1);\n    _offset integer := GREATEST((COALESCE(page, 1) - 1) * _limit, 0);\n    _search text := COALESCE(search_term, '');\nBEGIN\n    RETURN QUERY\n    WITH filtered AS (\n        SELECT\n            po.id,\n            po.status,\n            po.supplier_id,\n            s.name::text AS supplier_name,\n            po.created_at,\n            po.notes\n        FROM public.purchase_orders po\n        LEFT JOIN public.suppliers s ON s.id = po.supplier_id\n        WHERE po.deleted_at IS NULL\n          AND (\n            _search = ''\n            OR po.status ILIKE '%' || _search || '%'\n            OR po.notes ILIKE '%' || _search || '%'\n            OR po.id::text ILIKE '%' || _search || '%'\n            OR s.name ILIKE '%' || _search || '%'\n          )\n    ),\n    items AS (\n        SELECT\n            poi.purchase_order_id,\n            SUM(poi.quantity) AS total_quantity,\n            COUNT(*) AS total_items,\n            jsonb_agg(\n                jsonb_build_object(\n                    'product_id', poi.product_id,\n                    'product_name', p.name,\n                    'ordered_quantity', poi.quantity\n                )\n            ) AS items\n        FROM public.purchase_order_items poi\n        LEFT JOIN public.products p ON p.id = poi.product_id\n        GROUP BY poi.purchase_order_id\n    ),\n    entries AS (\n        SELECT\n            ie.purchase_order_id,\n            ie.product_id,\n            SUM(ie.quantity) AS received_quantity\n        FROM public.inventory_entries ie\n        LEFT JOIN public.inventory_entry_cancellations iec ON iec.inventory_entry_id = ie.id\n        WHERE iec.id IS NULL\n        GROUP BY ie.purchase_order_id, ie.product_id\n    ),\n    enriched AS (\n        SELECT\n            f.*,\n            i.total_items,\n            i.total_quantity,\n            i.items,\n            jsonb_agg(\n                jsonb_build_object(\n                    'product_id', item->>'product_id',\n                    'product_name', item->>'product_name',\n                    'ordered_quantity', (item->>'ordered_quantity')::numeric,\n                    'received_quantity', COALESCE(e.received_quantity, 0),\n                    'is_complete', COALESCE(e.received_quantity, 0) >= (item->>'ordered_quantity')::numeric\n                )\n            ) FILTER (WHERE i.items IS NOT NULL) AS completion_detail,\n            (\n                jsonb_build_object(\n                    'isComplete',\n                    CASE\n                        WHEN i.items IS NULL THEN false\n                        ELSE bool_and(COALESCE(e.received_quantity, 0) >= (item->>'ordered_quantity')::numeric)\n                    END,\n                    'totalItems', COALESCE(i.total_items, 0),\n                    'receivedItems',\n                    COALESCE(\n                        SUM(LEAST(COALESCE(e.received_quantity, 0), (item->>'ordered_quantity')::numeric)),\n                        0\n                    )\n                )\n            ) AS completion\n        FROM filtered f\n        LEFT JOIN items i ON i.purchase_order_id = f.id\n        LEFT JOIN LATERAL jsonb_array_elements(i.items) item ON true\n        LEFT JOIN entries e ON e.purchase_order_id = f.id AND e.product_id = (item->>'product_id')::uuid\n        GROUP BY\n            f.id,\n            f.status,\n            f.supplier_id,\n            f.supplier_name,\n            f.created_at,\n            f.notes,\n            i.total_items,\n            i.total_quantity,\n            i.items\n    ),\n    numbered AS (\n        SELECT\n            e.*,\n            COUNT(*) OVER () AS total_count,\n            ROW_NUMBER() OVER (ORDER BY e.created_at DESC) AS row_number\n        FROM enriched e\n    )\n    SELECT\n        n.id,\n        n.status,\n        n.supplier_id,\n        n.supplier_name,\n        n.created_at,\n        n.notes,\n        COALESCE(n.total_items, 0)::numeric AS total_items,\n        COALESCE(n.total_quantity, 0)::numeric AS total_quantity,\n        n.completion,\n        n.completion_detail,\n        n.total_count\n    FROM numbered n\n    WHERE n.row_number > _offset\n    ORDER BY n.row_number\n    LIMIT _limit;\nEND;\n"
    },
    {
        "routine_name": "get_movements_by_period",
        "routine_definition": "\nWITH all_movements AS (\n    -- Entradas\n    SELECT\n        ie.id,\n        'entry' AS movement_type,\n        ie.created_at,\n        p.name AS product_name,\n        p.sku AS product_sku,\n        p.barcode AS product_barcode,\n        ie.quantity,\n        w.name AS warehouse_name,\n        pr.full_name AS user_name,\n        s.name AS supplier_name,\n        ie.purchase_order_id,\n        NULL::uuid AS delivery_order_id,\n        NULL::text AS delivery_observations,\n        iec.id IS NOT NULL AS is_cancelled,\n        iec.observations AS cancellation_observations,\n        pr_cancel.full_name AS cancelled_by,\n        iec.created_at AS cancelled_at,\n        NULL::text AS delivered_to_name,\n        NULL::text AS delivered_to_id_number,\n        NULL::text AS delivered_to_type\n    FROM public.inventory_entries ie\n    LEFT JOIN public.products p ON p.id = ie.product_id\n    LEFT JOIN public.warehouses w ON w.id = ie.warehouse_id\n    LEFT JOIN public.profiles pr ON pr.id = ie.created_by\n    LEFT JOIN public.suppliers s ON s.id = ie.supplier_id\n    LEFT JOIN public.inventory_entry_cancellations iec ON iec.inventory_entry_id = ie.id\n    LEFT JOIN public.profiles pr_cancel ON pr_cancel.id = iec.created_by\n    WHERE ie.created_at >= start_date\n      AND ie.created_at <= end_date\n    \n    UNION ALL\n    \n    -- Salidas\n    SELECT\n        iex.id,\n        'exit' AS movement_type,\n        iex.created_at,\n        p.name AS product_name,\n        p.sku AS product_sku,\n        p.barcode AS product_barcode,\n        iex.quantity,\n        w.name AS warehouse_name,\n        pr.full_name AS user_name,\n        NULL AS supplier_name,\n        NULL AS purchase_order_id,\n        iex.delivery_order_id,\n        iex.delivery_observations,\n        iecx.id IS NOT NULL AS is_cancelled,\n        iecx.observations AS cancellation_observations,\n        pr_cancel.full_name AS cancelled_by,\n        iecx.created_at AS cancelled_at,\n        -- Información de \"Entregado a\"\n        CASE\n            WHEN iex.delivered_to_customer_id IS NOT NULL THEN c.name\n            WHEN iex.delivered_to_user_id IS NOT NULL THEN pr_delivered.full_name\n            ELSE NULL\n        END AS delivered_to_name,\n        CASE\n            WHEN iex.delivered_to_customer_id IS NOT NULL THEN c.id_number\n            ELSE NULL\n        END AS delivered_to_id_number,\n        CASE\n            WHEN iex.delivered_to_customer_id IS NOT NULL THEN 'customer'::text\n            WHEN iex.delivered_to_user_id IS NOT NULL THEN 'user'::text\n            ELSE NULL\n        END AS delivered_to_type\n    FROM public.inventory_exits iex\n    LEFT JOIN public.products p ON p.id = iex.product_id\n    LEFT JOIN public.warehouses w ON w.id = iex.warehouse_id\n    LEFT JOIN public.profiles pr ON pr.id = iex.created_by\n    LEFT JOIN public.inventory_exit_cancellations iecx ON iecx.inventory_exit_id = iex.id\n    LEFT JOIN public.profiles pr_cancel ON pr_cancel.id = iecx.created_by\n    LEFT JOIN public.customers c ON c.id = iex.delivered_to_customer_id AND c.deleted_at IS NULL\n    LEFT JOIN public.profiles pr_delivered ON pr_delivered.id = iex.delivered_to_user_id\n    WHERE iex.created_at >= start_date\n      AND iex.created_at <= end_date\n)\nSELECT\n    am.id,\n    am.movement_type,\n    am.created_at,\n    am.product_name,\n    am.product_sku,\n    am.product_barcode,\n    am.quantity,\n    am.warehouse_name,\n    am.user_name,\n    am.supplier_name,\n    am.purchase_order_id,\n    am.delivery_order_id,\n    am.delivery_observations,\n    am.is_cancelled,\n    am.cancellation_observations,\n    am.cancelled_by,\n    am.cancelled_at,\n    am.delivered_to_name,\n    am.delivered_to_id_number,\n    am.delivered_to_type\nFROM all_movements am\nORDER BY am.created_at DESC\nLIMIT movement_limit;\n"
    },
    {
        "routine_name": "update_purchase_order_edit_observation_updated_at",
        "routine_definition": "\nBEGIN\n    NEW.updated_at = NOW();\n    RETURN NEW;\nEND;\n"
    },
    {
        "routine_name": "get_products_for_return",
        "routine_definition": "\nBEGIN\n    IF return_type_param = 'purchase_order' THEN\n        RETURN QUERY\n        WITH received_by_product_warehouse AS (\n            -- Calcular cantidades recibidas por producto-bodega\n            SELECT\n                ie.product_id,\n                ie.warehouse_id,\n                SUM(ie.quantity) AS total_received\n            FROM public.inventory_entries ie\n            WHERE ie.purchase_order_id = order_id_param\n            GROUP BY ie.product_id, ie.warehouse_id\n        ),\n        returned_by_product_warehouse AS (\n            -- Calcular cantidades ya devueltas por producto-bodega\n            SELECT\n                r.product_id,\n                r.warehouse_id,\n                SUM(r.quantity) AS total_returned\n            FROM public.returns r\n            WHERE r.return_type = 'purchase_order'\n              AND r.order_id = order_id_param\n            GROUP BY r.product_id, r.warehouse_id\n        ),\n        products_with_quantities AS (\n            SELECT\n                r.product_id,\n                r.warehouse_id,\n                r.total_received,\n                COALESCE(ret.total_returned, 0) AS total_returned,\n                (r.total_received - COALESCE(ret.total_returned, 0)) AS max_returnable\n            FROM received_by_product_warehouse r\n            LEFT JOIN returned_by_product_warehouse ret \n                ON ret.product_id = r.product_id \n                AND ret.warehouse_id = r.warehouse_id\n            WHERE (r.total_received - COALESCE(ret.total_returned, 0)) > 0\n        )\n        SELECT\n            pwq.product_id,\n            p.name::text AS product_name,\n            p.sku::text AS product_sku,\n            pwq.warehouse_id,\n            w.name::text AS warehouse_name,\n            pwq.max_returnable,\n            pwq.total_returned AS already_returned\n        FROM products_with_quantities pwq\n        LEFT JOIN public.products p ON p.id = pwq.product_id\n        LEFT JOIN public.warehouses w ON w.id = pwq.warehouse_id\n        WHERE p.id IS NOT NULL\n        ORDER BY p.name, w.name;\n        \n    ELSIF return_type_param = 'delivery_order' THEN\n        RETURN QUERY\n        WITH returned_by_product_warehouse AS (\n            -- Calcular cantidades ya devueltas por producto-bodega\n            SELECT\n                r.product_id,\n                r.warehouse_id,\n                SUM(r.quantity) AS total_returned\n            FROM public.returns r\n            WHERE r.return_type = 'delivery_order'\n              AND r.order_id = order_id_param\n            GROUP BY r.product_id, r.warehouse_id\n        ),\n        items_with_returns AS (\n            SELECT\n                doi.product_id,\n                doi.warehouse_id,\n                doi.delivered_quantity,\n                COALESCE(ret.total_returned, 0) AS total_returned,\n                (doi.delivered_quantity - COALESCE(ret.total_returned, 0)) AS max_returnable\n            FROM public.delivery_order_items doi\n            LEFT JOIN returned_by_product_warehouse ret \n                ON ret.product_id = doi.product_id \n                AND ret.warehouse_id = doi.warehouse_id\n            WHERE doi.delivery_order_id = order_id_param\n              AND doi.delivered_quantity > 0\n              AND (doi.delivered_quantity - COALESCE(ret.total_returned, 0)) > 0\n        )\n        SELECT\n            iwr.product_id,\n            p.name::text AS product_name,\n            p.sku::text AS product_sku,\n            iwr.warehouse_id,\n            w.name::text AS warehouse_name,\n            iwr.max_returnable,\n            iwr.total_returned AS already_returned\n        FROM items_with_returns iwr\n        LEFT JOIN public.products p ON p.id = iwr.product_id\n        LEFT JOIN public.warehouses w ON w.id = iwr.warehouse_id\n        WHERE p.id IS NOT NULL\n        ORDER BY p.name, w.name;\n    ELSE\n        -- Retornar vacío si el tipo no es válido\n        RETURN;\n    END IF;\nEND;\n"
    },
    {
        "routine_name": "get_products_dashboard",
        "routine_definition": "\nDECLARE\n    _limit integer := GREATEST(COALESCE(page_size, 5), 1);\n    _offset integer := GREATEST((COALESCE(page, 1) - 1) * _limit, 0);\n    _search text := COALESCE(search_term, '');\nBEGIN\n    RETURN QUERY\n    WITH filtered AS (\n        SELECT\n            p.id,\n            p.name,\n            p.sku,\n            p.barcode,\n            p.status,\n            p.created_at::timestamptz AS created_at,\n            p.brand_id,\n            b.name::text AS brand_name,\n            p.category_id,\n            c.name::text AS category_name,\n            p.color_id,\n            col.name::text AS color_name\n        FROM public.products p\n        LEFT JOIN public.brands b ON b.id = p.brand_id\n        LEFT JOIN public.category c ON c.id = p.category_id\n        LEFT JOIN public.colors col ON col.id = p.color_id AND col.deleted_at IS NULL\n        WHERE p.deleted_at IS NULL\n          AND (\n            _search = ''\n            OR p.name ILIKE '%' || _search || '%'\n            OR p.sku ILIKE '%' || _search || '%'\n            OR p.barcode ILIKE '%' || _search || '%'\n            OR b.name ILIKE '%' || _search || '%'\n            OR c.name ILIKE '%' || _search || '%'\n            OR col.name ILIKE '%' || _search || '%'\n          )\n    ),\n    aggregated AS (\n        SELECT\n            f.id,\n            f.name,\n            f.sku,\n            f.barcode,\n            f.status,\n            f.created_at,\n            f.brand_id,\n            f.brand_name,\n            f.category_id,\n            f.category_name,\n            f.color_id,\n            f.color_name,\n            COALESCE(\n                SUM(ws.quantity) FILTER (WHERE w.is_active)::numeric,\n                0::numeric\n            ) AS total_stock,\n            COALESCE(\n                jsonb_agg(\n                    jsonb_build_object(\n                        'warehouseId', ws.warehouse_id,\n                        'warehouseName', w.name,\n                        'quantity', ws.quantity\n                    )\n                ) FILTER (WHERE w.is_active),\n                '[]'::jsonb\n            ) AS stock_by_warehouse\n        FROM filtered f\n        LEFT JOIN public.warehouse_stock ws ON ws.product_id = f.id\n        LEFT JOIN public.warehouses w ON w.id = ws.warehouse_id\n        GROUP BY\n            f.id,\n            f.name,\n            f.sku,\n            f.barcode,\n            f.status,\n            f.created_at,\n            f.brand_id,\n            f.brand_name,\n            f.category_id,\n            f.category_name,\n            f.color_id,\n            f.color_name\n    ),\n    numbered AS (\n        SELECT\n            a.*,\n            COUNT(*) OVER () AS total_count,\n            ROW_NUMBER() OVER (ORDER BY a.created_at DESC) AS row_number\n        FROM aggregated a\n    )\n    SELECT\n        n.id,\n        n.name,\n        n.sku,\n        n.barcode,\n        n.status,\n        n.created_at,\n        n.brand_id,\n        n.brand_name,\n        n.category_id,\n        n.category_name,\n        n.color_id,\n        n.color_name,\n        n.total_stock,\n        n.stock_by_warehouse,\n        n.total_count\n    FROM numbered n\n    WHERE n.row_number > _offset\n    ORDER BY n.row_number\n    LIMIT _limit;\nEND;\n"
    },
    {
        "routine_name": "get_orders_for_return",
        "routine_definition": "\nBEGIN\n    IF return_type_param = 'purchase_order' THEN\n        RETURN QUERY\n        SELECT\n            po.id,\n            po.order_number,\n            COALESCE(po.order_number, 'OC-' || SUBSTRING(po.id::text, 1, 8)) AS display_name\n        FROM public.purchase_orders po\n        WHERE po.status != 'cancelled'\n          AND po.deleted_at IS NULL\n          AND EXISTS (\n              SELECT 1 \n              FROM public.inventory_entries ie\n              WHERE ie.purchase_order_id = po.id\n          )\n        ORDER BY po.created_at DESC;\n        \n    ELSIF return_type_param = 'delivery_order' THEN\n        RETURN QUERY\n        SELECT\n            dord.id,\n            dord.order_number,\n            COALESCE(dord.order_number, 'OE-' || SUBSTRING(dord.id::text, 1, 8)) AS display_name\n        FROM public.delivery_orders dord\n        WHERE dord.status != 'cancelled'\n          AND dord.deleted_at IS NULL\n          AND EXISTS (\n              SELECT 1 \n              FROM public.inventory_exits iex\n              WHERE iex.delivery_order_id = dord.id\n          )\n        ORDER BY dord.created_at DESC;\n    ELSE\n        -- Retornar vacío si el tipo no es válido\n        RETURN;\n    END IF;\nEND;\n"
    },
    {
        "routine_name": "update_zones_updated_at",
        "routine_definition": "\nBEGIN\n    NEW.updated_at = NOW();\n    RETURN NEW;\nEND;\n"
    },
    {
        "routine_name": "get_customer_exit_history",
        "routine_definition": "\nDECLARE\n    offset_val integer;\nBEGIN\n    offset_val := GREATEST((COALESCE(page, 1) - 1) * COALESCE(page_size, 50), 0);\n    \n    RETURN QUERY\n    WITH total AS (\n        SELECT COUNT(*)::bigint AS cnt\n        FROM public.inventory_exits ie\n        WHERE ie.delivered_to_customer_id = customer_id_param\n    )\n    SELECT \n        ie.id,\n        p.name::text AS product_name,\n        w.name::text AS warehouse_name,\n        ie.quantity,\n        ie.created_at,\n        creator.full_name::text AS created_by_name,\n        EXISTS(\n            SELECT 1 FROM public.inventory_exit_cancellations iec \n            WHERE iec.inventory_exit_id = ie.id\n        ) AS is_cancelled,\n        total.cnt AS total_count\n    FROM public.inventory_exits ie\n    LEFT JOIN public.products p ON p.id = ie.product_id\n    LEFT JOIN public.warehouses w ON w.id = ie.warehouse_id\n    LEFT JOIN public.profiles creator ON creator.id = ie.created_by\n    CROSS JOIN total\n    WHERE ie.delivered_to_customer_id = customer_id_param\n    ORDER BY ie.created_at DESC\n    LIMIT GREATEST(COALESCE(page_size, 50), 1)\n    OFFSET offset_val;\nEND;\n"
    },
    {
        "routine_name": "get_orders_for_return",
        "routine_definition": "\nBEGIN\n    IF return_type_param = 'purchase_order' THEN\n        RETURN QUERY\n        SELECT\n            po.id,\n            po.order_number,\n            COALESCE(po.order_number, 'OC-' || SUBSTRING(po.id::text, 1, 8)) AS display_name\n        FROM public.purchase_orders po\n        WHERE po.status != 'cancelled'\n          AND po.deleted_at IS NULL\n          AND EXISTS (\n              SELECT 1 \n              FROM public.inventory_entries ie\n              WHERE ie.purchase_order_id = po.id\n          )\n          AND (\n              search_term = ''\n              OR LOWER(po.order_number) LIKE '%' || LOWER(search_term) || '%'\n              OR LOWER(COALESCE(po.order_number, 'OC-' || SUBSTRING(po.id::text, 1, 8))) LIKE '%' || LOWER(search_term) || '%'\n              OR po.id::text LIKE '%' || search_term || '%'\n          )\n        ORDER BY po.created_at DESC\n        LIMIT 50; -- Limitar resultados para mejor rendimiento\n        \n    ELSIF return_type_param = 'delivery_order' THEN\n        RETURN QUERY\n        SELECT\n            dord.id,\n            dord.order_number,\n            COALESCE(dord.order_number, 'OE-' || SUBSTRING(dord.id::text, 1, 8)) AS display_name\n        FROM public.delivery_orders dord\n        WHERE dord.status != 'cancelled'\n          AND dord.deleted_at IS NULL\n          AND EXISTS (\n              SELECT 1 \n              FROM public.inventory_exits iex\n              WHERE iex.delivery_order_id = dord.id\n          )\n          AND (\n              search_term = ''\n              OR LOWER(dord.order_number) LIKE '%' || LOWER(search_term) || '%'\n              OR LOWER(COALESCE(dord.order_number, 'OE-' || SUBSTRING(dord.id::text, 1, 8))) LIKE '%' || LOWER(search_term) || '%'\n              OR dord.id::text LIKE '%' || search_term || '%'\n          )\n        ORDER BY dord.created_at DESC\n        LIMIT 50; -- Limitar resultados para mejor rendimiento\n    ELSE\n        -- Retornar vacío si el tipo no es válido\n        RETURN;\n    END IF;\nEND;\n"
    },
    {
        "routine_name": "get_customers",
        "routine_definition": "\nDECLARE\n  offset_val integer;\nBEGIN\n  offset_val := (page - 1) * page_size;\n\n  RETURN QUERY\n  WITH total AS (\n    SELECT COUNT(*) as cnt\n    FROM customers c\n    WHERE deleted_at IS NULL\n      AND (\n        search_term IS NULL \n        OR c.name ILIKE '%' || search_term || '%'\n        OR c.id_number ILIKE '%' || search_term || '%'\n        OR c.phone ILIKE '%' || search_term || '%'\n      )\n  )\n  SELECT \n    c.id,\n    c.name,\n    c.id_number,\n    c.phone,\n    c.email,\n    c.address,\n    COUNT(ie.id) AS total_exits,\n    MAX(ie.created_at) AS last_exit_date,\n    total.cnt AS total_count\n  FROM customers c\n  LEFT JOIN inventory_exits ie ON ie.delivered_to_customer_id = c.id\n  CROSS JOIN total\n  WHERE c.deleted_at IS NULL\n    AND (\n      search_term IS NULL \n      OR c.name ILIKE '%' || search_term || '%'\n      OR c.id_number ILIKE '%' || search_term || '%'\n      OR c.phone ILIKE '%' || search_term || '%'\n    )\n  GROUP BY c.id, c.name, c.id_number, c.phone, c.email, c.address, total.cnt\n  ORDER BY c.name\n  LIMIT page_size\n  OFFSET offset_val;\nEND;\n"
    }
]